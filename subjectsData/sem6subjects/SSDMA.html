<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Practicals List</title>
    <link rel="stylesheet" href="../../styles.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f5f5f5;
        }

        .navbar {
            background-color: #0B0425;
            color: #fff;
            padding: 15px 20px;
        }

        .navbar .brand {
            text-decoration: none;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
        }

        .semester1 .section {
            background-color: #1f2937;
            padding: 4rem 2rem;
            margin-top: 4rem;
            position: relative;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
        }

        .semester1 .section-title {
            font-size: 2.0rem;
            margin-bottom: 1.5rem;
            color: #f3f4f6;
            font-weight: 800;
        }

        .semester1 .practicals-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        .semester1 .practicals-list .card {
            background: linear-gradient(to right, rgb(45, 45, 197),rgba(64, 201, 116, 0.678), rgb(45, 45, 197));
            border-radius: 0.375rem;
            padding: 1.5rem;
            margin-bottom: 1.0rem;
            color: #f3f4f6;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, transform 0.3s ease;
            text-align: center;
        }

        .semester1 .practicals-list .card:hover {
            background-color: #4b5563;
            transform: scale(1.02);
        }

        .semester1 .card-title {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #f3f4f6;
            font-weight: 700;
        }

        .semester1 .theoretical-content,
        .semester1 .code-block {
            display: none;
            text-align: left;
            overflow: hidden;
            transition: max-height 0.4s ease;
            background-color: #1e293b;
            padding: 20px;
            border-radius: 0.375rem;
            margin-top: 1rem;
        }

        .semester1 .theoretical-content h3,
        .semester1 .theoretical-content h4,
        .semester1 .theoretical-content h5,
        .semester1 .theoretical-content p,
        .semester1 .theoretical-content ul {
            text-align: left;
            color: #f3f4f6;
        }

        .semester1 .theoretical-content h3 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .semester1 .theoretical-content h4 {
            font-size: 1.75rem;
            margin-top: 1.5rem;
        }

        .semester1 .theoretical-content h5 {
            font-size: 1.5rem;
            margin-top: 1rem;
        }

        .semester1 .theoretical-content p {
            font-size: 1.125rem;
            margin: 0.5rem 0;
            line-height: 1.8;
        }

        .semester1 .theoretical-content ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .semester1 .theoretical-content ul li {
            margin-bottom: 0.5rem;
        }

        .semester1 .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1rem;
            border-radius: 0.375rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
        }

        .reveal-button {
            background-color: #0B0425;
            color: #fff;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 1.125rem;
            margin-top: 1rem;
            transition: background-color 0.3s ease;
            display: block;
            width: 100%;
            text-align: center;
        }

        .reveal-button:hover {
            background-color: #1e40af;
        }

        .container {
            display: inline-block;
            justify-content: space-between;
            align-items: flex-start;
            gap: 2rem;
            width: 200px;
            margin-left: auto;
            margin-right: auto;

        }

        .semester1.section {
            flex: 1;
        }

        .video-section {
            
            background-color: #1f2937;
            padding: 2rem;
            border-radius: 0.375rem;
            text-align:left;
        }
        .video-section2 {
          
            background-color: #1f2937;
            padding: 2rem;
            border-radius: 0.375rem;
            text-align:right;
        }

        .video-title {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #f3f4f6;
            font-weight: 700;
        }

        .video-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .video-container iframe {
            border-radius: 0.375rem;
        }
        .download-button {
            width: 30vw;
            display: inline-block;
            padding: 1vh 2vh;
            font-size: 3vh;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            margin-bottom: 3vh;
        }

        .download-button:hover {
            background-color: #0056b3;
        }

        .INFO
        {
            padding: 1vh 2vh;
            font-size: 4vh;
            display: block;
            margin-bottom: 2vh;
            color: rgb(255, 255, 255);
            align-items: center;
            justify-content: center;
            background-color: #0056b3;
            border-radius: 10px;
            max-width: 50vw;
            max-height: 10vw;
            margin: 3vh auto;
        }

        pre1 .output
        {
            display: inline-block;
            justify-content: space-between;
        }

               
@media (max-width: 425px) {
    .semester1 .theoretical-content h3 {
        font-size: 1.6rem;
        margin-bottom: 1rem;
    }

    .semester1 .theoretical-content h4 {
        font-size: 1.35rem;
        margin-top: 1.5rem;
    }

    .semester1 .theoretical-content h5 {
        font-size: 1.3rem;
        margin-top: 1rem;
    }

    .semester1 .theoretical-content p {
        font-size: 1rem;
        margin: 0.5rem 0;
        line-height: 1.8;
    }

    .semester1 .theoretical-content ul {
        margin: 0.3rem 0;
        padding-left: 1.5rem;
    }

    .semester1 .theoretical-content ul li {
        margin-bottom: 0.3rem;
    }

   .video-section iframe{
        width: 230px;
        height: 157px;
    }
    .card{
        width: 95%;
    }

    .semester1 .theoretical-content,
        .semester1 .code-block {
            display: none;
            text-align: left;
            overflow: hidden;
            transition: max-height 0.4s ease;
            background-color: #1e293b;
            padding: 15px;
            border-radius: 0.375rem;
            margin-top: 1rem;
        }
        .Output img{
            width: 260px;
            height: 170px;
        }
        .code-block code{
                font-size: 0.8rem;
        }
    
}
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="container">
            <a href="../../semestershtml/semester6.html" class="brand">Back to Subjects</a>
        </div>
    </nav>

    <!-- Semester 6 Practicals Section -->
    <section class="semester1 section">
        <h1 class="section-title">STATISTICS, STATISTICAL MODELLING & DATA ANALYTICS LAB Practicals</h1>

        <a href="../../files/ssdma.pdf" download="STATISTICS, STATISTICAL MODELLING & DATA ANALYTICS LAB.pdf" class="download-button">Download PDF</a>
        
        <div class="INFO">
            <p>Video + Theory</p>
        </div>

        <ul class="practicals-list">
            <!-- Experiment 1 -->
            <li class="card">
                <h2 class="card-title">Experiment No. 1: Basic Matrix Operations in Scilab</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent1', 'codeBlock1', 'resultsBlock1')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent1" class="theoretical-content">
                    <h3>Aim/Objective</h3>
                    <p>Exercises to implement the basic matrix operations in Scilab.</p>
                    
                    <h3>Theory</h3>
                    <p>Matrix operations are fundamental in various fields of science and engineering, including mathematics, physics, computer science, and data analysis. Scilab is a powerful tool for performing numerical computations, making it suitable for implementing and experimenting with matrix operations.</p>
                    
                    <h3>Methods</h3>
                    <ol>
                        <li>Matrix Definition: Define matrices A and B using the <code>matrix</code> function in Scilab.</li>
                        <li>Matrix Addition: Perform matrix addition using the <code>+</code> operator.</li>
                        <li>Matrix Subtraction: Perform matrix subtraction using the <code>-</code> operator.</li>
                        <li>Matrix Multiplication: Perform matrix multiplication using the <code>*</code> operator.</li>
                        <li>Matrix Transposition: Transpose a matrix using the <code>'</code> operator.</li>
                    </ol>
                    
                    <h3>Results</h3>
                    <ul>
                        <li>Matrix Addition:
                            <pre><code>
8  10  12
14 16  18
                            </code></pre>
                        </li>
                        <li>Matrix Subtraction:
                            <pre><code>
-6  -6  -6
-6  -6  -6
                            </code></pre>
                        </li>
                        <li>Matrix Multiplication:
                            <pre><code>
50  122
68  167
                            </code></pre>
                        </li>
                        <li>Matrix Transposition:
                            <pre><code>
1  4
2  5
3  6
                            </code></pre>
                        </li>
                    </ul>
                    
                    <h3>Discussion</h3>
                    <p>The implementation of basic matrix operations in Scilab yielded the expected results. Matrix addition and subtraction produced matrices with correct element-wise sums and differences. Matrix multiplication adhered to the rules of matrix multiplication. Matrix transposition effectively converted rows into columns and vice versa.</p>
                    
                    <h3>Conclusion</h3>
                    <p>This lab successfully demonstrated the implementation of basic matrix operations in Scilab. The results obtained align with the expected outcomes, validating the accuracy of the implemented operations.</p>
                    <h3>Viva Questions</h3>
    <ol>
        <li><strong>Explain the difference between element-wise multiplication and matrix multiplication in Scilab.</strong>
            <p>Element-wise multiplication in Scilab is performed using the <code>.*</code> operator, where each corresponding element of two matrices is multiplied together. Matrix multiplication, on the other hand, is performed using the <code>*</code> operator, following the standard rules of matrix multiplication where rows and columns are multiplied and summed accordingly. Element-wise multiplication results in a matrix of the same size as the operands, while matrix multiplication may yield a different-sized matrix depending on the dimensions of the operands.</p>
        </li>
        <br><hr>
        <li><strong>Explain the concept of matrix inversion and its relevance in numerical computations.</strong>
            <p>Matrix inversion involves finding a matrix that, when multiplied by the original matrix, yields the identity matrix. In numerical computations, matrix inversion is relevant for solving systems of linear equations, computing determinants, and solving optimization problems. However, not all matrices are invertible (non-singular). In Scilab, matrix inversion can be computed using the <code>inv</code> function, but it's important to note that the inversion process can be numerically unstable for certain matrices, especially those that are ill-conditioned.</p>
        </li>
        <br><hr>
        <li><strong>Discuss the computational complexity of matrix multiplication and its implications for large-scale numerical computations.</strong>
            <p>The computational complexity of matrix multiplication depends on the dimensions of the matrices involved. For two matrices of dimensions m×n and n×p, the standard matrix multiplication algorithm (e.g., the naïve method) has a complexity of O(m×n×p). This implies that as the size of the matrices increases (especially in large-scale numerical computations), the computational cost of matrix multiplication grows significantly. To address this, various optimized algorithms (e.g., Strassen's algorithm, Coppersmith-Winograd algorithm) have been developed to reduce the computational complexity and improve efficiency in large-scale matrix computations.</p>
        </li>
    </ol>
                </div>
                
                <div id="codeBlock1" class="code-block">
                    <h3>Sample Scilab Code</h3>
                    <pre><code>
A = matrix([1, 2, 3; 4, 5, 6]);
B = matrix([7, 8, 9; 10, 11, 12]);

C_addition = A + B;
disp(C_addition);

C_subtraction = A - B;
disp(C_subtraction);

C_multiplication = A * B';
disp(C_multiplication);

A_transpose = A';
disp(A_transpose);
<br>
<br>
<hr>
<h1>Results</h1><ul><code><pre></pre></code>
                        <li>Matrix Addition:<pre><code>
8  10  12
14 16  18
                            </code></pre>
                        </li>
                        <li>Matrix Subtraction:<pre><code>
-6  -6  -6
-6  -6  -6
                            </code></pre>
                        </li>
                        <li>Matrix Multiplication:<pre><code>
50  122
68  167
                            </code></pre>
                        </li>
                        <li>Matrix Transposition:<pre><code>
1  4
2  5
3  6</code></pre>
                        </li>
                    </ul>



                    </code></pre>
                </div>

                <div id="resultsBlock1" class="results-block">
                    
                </div>
            </li>
            
            <!-- Experiment 2 -->
            <li class="card">
                <h2 class="card-title">Experiment No. 2: Eigenvalues and Eigenvectors in Scilab</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent2', 'codeBlock2', 'resultsBlock2')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent2" class="theoretical-content">
                    <h3>Aim/Objective</h3>
                    <p>Exercises to find the Eigenvalues and eigenvectors in Scilab.</p>
                    
                    <h3>Theory</h3>
                    <p>Eigenvalues and eigenvectors are properties of square matrices that represent how the matrix behaves when multiplied by certain vectors. They are used in diverse applications, such as stability analysis of dynamic systems, principal component analysis in data science, and solving differential equations. Scilab offers efficient tools for computing eigenvalues and eigenvectors.</p>
                    
                    <h3>Methods</h3>
                    <ol>
                        <li>Matrix Definition: Define a square matrix A using the <code>matrix</code> function in Scilab.</li>
                        <li>Eigenvalue Computation: Use the <code>spec</code> function to compute the eigenvalues of matrix A.</li>
                        <li>Eigenvector Computation: Compute the eigenvectors corresponding to the eigenvalues using the <code>spec</code> function.</li>
                    </ol>
                    
                    <h3>Results</h3>
                    <ul>
                        <li>Eigenvalues:
                            <pre><code>
16.1168
-1.1168
0.0000
                            </code></pre>
                        </li>
                        <li>Eigenvectors:
                            <pre><code>
-0.2319705  0.7858302  -0.4082483
-0.5253221  0.0867513  -0.8164966
-0.8186736 -0.6123276   0.4082483
                            </code></pre>
                        </li>
                    </ul>
                    
                    <h3>Discussion</h3>
                    <p>The computation of eigenvalues and eigenvectors using Scilab yielded meaningful results. Eigenvalues represent the scaling factor by which the eigenvectors are stretched or shrunk when multiplied by the matrix. Eigenvectors are the directions in which the matrix transformation occurs without rotation.</p>
                    
                    <h3>Conclusion</h3>
                    <p>This experiment demonstrated the computation of eigenvalues and eigenvectors in Scilab. By analyzing these properties, we gain insights into the behavior of linear systems and matrices. Scilab's efficient algorithms facilitate the computation of these properties, making it a valuable tool for numerical linear algebra tasks.</p>
                    <h3>Viva Questions</h3>
                    <ol>
                        <li><strong>What is the purpose of finding eigenvalues and eigenvectors in Scilab?</strong>
                            <p>• The purpose of finding eigenvalues and eigenvectors in Scilab is to analyze the behavior of linear transformations represented by matrices. Eigenvalues represent the scaling factors by which eigenvectors are stretched or shrunk, while eigenvectors represent the directions along which the transformation occurs without rotation. This information is useful in various applications, such as stability analysis, data analysis, and solving differential equations.</p>
                        </li>
                        <br><hr>
                        <li><strong>What is the significance of eigenvalues in the context of matrices?</strong>
                            <p>• Eigenvalues provide important information about the properties of matrices. For example, they can indicate whether a matrix is invertible (non-singular) or not. Additionally, eigenvalues are used in various mathematical and scientific computations, such as solving systems of linear equations, analyzing dynamic systems, and performing principal component analysis (PCA) in data analysis.</p>
                        </li>
                        <br><hr>
                        <li><strong>Can a matrix have complex eigenvalues and eigenvectors?</strong>
                            <p>• Yes, a matrix can have complex eigenvalues and eigenvectors, especially when the matrix is not symmetric. Complex eigenvalues and eigenvectors indicate that the transformation represented by the matrix involves rotation as well as scaling.</p>
                        </li>
                        <br><hr>
                        <li><strong>What is the relationship between eigenvalues and the determinant of a matrix?</strong>
                            <p>• The product of the eigenvalues of a matrix is equal to its determinant. Mathematically, if λ1, λ2, ..., λn are the eigenvalues of a square matrix A, then det(A) = λ1 ⋅ λ2 ⋅ ... ⋅ λn.</p>
                        </li>
                    </ol>
                </div>
                
                <div id="codeBlock2" class="code-block">
                    <h3>Sample Scilab Code</h3>
                    <pre><code>
A = matrix([1, 2, 3; 4, 5, 6; 7, 8, 9]);

[eigenvalues, eigenvectors] = spec(A);
disp(eigenvalues);
disp(eigenvectors);

</code></pre>
<br><br><hr>

<h1>Results</h1>  <ul><li>Eigenvalues:
                            <pre><code>
16.1168
-1.1168
0.0000                  </code></pre>
                        </li>
                        <li>Eigenvectors:<pre><code>
-0.2319705  0.7858302  -0.4082483
-0.5253221  0.0867513  -0.8164966
-0.8186736 -0.6123276   0.4082483
                            </code></pre>
                        </li>
                    </ul>
                    </code></pre>
                </div>

                <div id="resultsBlock2" class="results-block">
                    
                </div>
            </li>

            <li class="card">
                <h2 class="card-title">Experiment No. 3: Solving Equations by Gauss Elimination, Gauss-Jordan Method, and Gauss-Seidel in Scilab</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent3', 'codeBlock3', 'resultsBlock3')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent3" class="theoretical-content">
                    <h3>Aim</h3>
                    <p>Exercises to solve equations by Gauss Elimination, Gauss-Jordan Method, and Gauss-Seidel in Scilab.</p>
                    
                    <h3>Software Used</h3>
                    <p>Scientific computing software package</p>
                    
                    <h3>Introduction</h3>
                    <p>The objective of this experiment is to understand and implement three different methods for solving systems of linear equations: Gauss Elimination, Gauss-Jordan Method, and Gauss-Seidel Iteration using Scilab. These methods will be compared in terms of their accuracy, efficiency, and applicability. Solving systems of linear equations is a fundamental problem in mathematics and engineering. In this lab, we explore these methods using Scilab, which is a powerful numerical computing environment.</p>
                    
                    <h3>Procedure</h3>
                    <ol>
                        <li>
                            <strong>Gauss Elimination:</strong>
                            <pre><code>
function x = gauss_elimination(A, b)
n = size(A, 1);
Ab = [A b];
for k = 1:n-1
    for i = k+1:n
        factor = Ab(i,k)/Ab(k,k);
        Ab(i,k:n+1) = Ab(i,k:n+1) - factor * Ab(k,k:n+1);
    end
end
x = zeros(n, 1);
x(n) = Ab(n,n+1)/Ab(n,n);
for i = n-1:-1:1
    x(i) = (Ab(i,n+1) - Ab(i,i+1:n)*x(i+1:n))/Ab(i,i);
end
endfunction

A = [2 1 -1; -3 -1 2; -2 1 2];
b = [8; -11; -3];
x_gauss = gauss_elimination(A, b);
disp('Solution using Gauss Elimination:');
disp(x_gauss);
            </code></pre>
        </li>
        <li>
            <strong>Gauss-Jordan Method:</strong>
            <pre><code>
function x = gauss_jordan(A, b)
n = size(A, 1);
Ab = [A b];
for k = 1:n
    Ab(k,:) = Ab(k,:)/Ab(k,k);
    for i = 1:n
        if i ~= k
            factor = Ab(i,k);
            Ab(i,:) = Ab(i,:) - factor * Ab(k,:);
        end
    end
end
x = Ab(:,end);
endfunction

A = [2 1 -1; -3 -1 2; -2 1 2];
b = [8; -11; -3];
x_gauss_jordan = gauss_jordan(A, b);
disp('Solution using Gauss-Jordan Method:');
disp(x_gauss_jordan);
                            </code></pre>
                        </li>
                        <li>
                            <strong>Gauss-Seidel Iteration:</strong>
                            <pre><code>
function x = gauss_seidel(A, b, x0, tol, max_iter)
n = length(b);
x = x0;
for iter = 1:max_iter
    x_old = x;
    for i = 1:n
        sigma = 0;
        for j = 1:n
            if j ~= i
                sigma = sigma + A(i,j) * x(j);
            end
        end
        x(i) = (b(i) - sigma) / A(i,i);
    end
    if norm(x - x_old, inf) < tol
        disp('Convergence achieved in iterations:');
        disp(iter);
        return;
    end
end
disp('Maximum iterations reached without convergence.');
endfunction

A = [4 -1 0; -1 4.25 2.5; 0 2.5 5.25];
b = [2; 1; 2];
x0 = [0; 0; 0];
tol = 1e-6;
max_iter = 1000;
disp('Performing Gauss-Seidel Iteration:');
gauss_seidel(A, b, x0, tol, max_iter);
                            </code></pre>
                        </li>
                    </ol>
                    
                    <h3>Discussion</h3>
                    <ul>
                        <li>Gauss Elimination and Gauss-Jordan Method provide exact solutions but may suffer from numerical instability for ill-conditioned matrices.</li>
                        <li>Gauss-Seidel Iteration is efficient for large systems and can handle diagonally dominant matrices well.</li>
                    </ul>
                    
                    <h3>Conclusion</h3>
                    <p>In this lab experiment, we successfully implemented and compared three different methods for solving systems of linear equations using Scilab. Each method has its advantages and limitations, and the choice of method depends on the specific characteristics of the system being solved. Gauss Elimination and Gauss-Jordan Method provide exact solutions but may be less efficient for large systems, while Gauss-Seidel Iteration offers efficiency for large systems but requires certain conditions for convergence.</p>
                    
                    <h3>Viva Questions</h3>
                    <ol><br><hr>
                        <li><strong>Can you explain the difference between Gauss Elimination and Gauss-Jordan Method?</strong>
                            <p>• Gauss Elimination: It is a method for solving systems of linear equations by performing elementary row operations on the augmented matrix to transform it into row echelon form. After obtaining the row echelon form, back-substitution is used to find the solution.</p>
                            <p>• Gauss-Jordan Method: Similar to Gauss Elimination, but it further transforms the row echelon form into reduced row echelon form directly. This results in obtaining the solution of the system without the need for back-substitution.</p>
                        </li>
                        <br><hr>
                        <li><strong>Why is it important to check for convergence in the Gauss-Seidel Iteration method?</strong>
                            <p>• Gauss-Seidel Iteration is an iterative method used to solve systems of linear equations. It involves updating the values of the variables iteratively until convergence is achieved. Checking for convergence ensures that the iterative process stops when the solution stabilizes and further iterations do not significantly change the result. Without convergence, the solution obtained may not be accurate or reliable.</p>
                        </li><br><hr>
                        <li><strong>What are the advantages and disadvantages of using Gauss Elimination and Gauss-Jordan Method?</strong>
                            <p><strong>Advantages:</strong></p>
                            <ul>
                                <li>Both methods provide exact solutions for systems of linear equations.</li>
                                <li>They are straightforward to implement and understand.</li>
                            </ul>
                            <p><strong>Disadvantages:</strong></p>
                            <ul>
                                <li>Gauss Elimination and Gauss-Jordan Method may suffer from numerical instability for ill-conditioned matrices, leading to loss of accuracy.</li>
                                <li>They require significant computational resources, especially for large systems, due to the need for matrix manipulation.</li>
                            </ul>
                        </li>
                        <br><hr>
                        <li><strong>When is Gauss-Seidel Iteration preferred over Gauss Elimination and Gauss-Jordan Method?</strong>
                            <p>Gauss-Seidel Iteration is preferred over Gauss Elimination and Gauss-Jordan Method in the following scenarios:</p>
                            <ul>
                                <li>For large systems of linear equations where computational efficiency is crucial, as Gauss-Seidel Iteration converges faster for such systems.</li>
                                <li>When dealing with diagonally dominant matrices, as Gauss-Seidel Iteration is particularly effective for such matrices and may converge even when other methods fail.</li>
                            </ul>
                        </li>
                        <br><hr>
                        <li><strong>How does the choice of initial guess affect the convergence of Gauss-Seidel Iteration?</strong>
                            <p>The choice of initial guess can significantly affect the convergence of Gauss-Seidel Iteration. A good initial guess that is close to the true solution can lead to faster convergence, while a poor initial guess may result in slow convergence or even divergence. Therefore, selecting an appropriate initial guess is important to ensure the efficiency and accuracy of the iterative process.</p>
                        </li>
                    </ol>
                </div>
                
                <div id="codeBlock3" class="code-block">
                    <h3>Sample Scilab Code</h3>
                    <pre><code>
function x = gauss_elimination(A, b)
n = size(A, 1);
Ab = [A b];
for k = 1:n-1
    for i = k+1:n
        factor = Ab(i,k)/Ab(k,k);
        Ab(i,k:n+1) = Ab(i,k:n+1) - factor * Ab(k,k:n+1);
    end
end
x = zeros(n, 1);
x(n) = Ab(n,n+1)/Ab(n,n);
for i = n-1:-1:1
    x(i) = (Ab(i,n+1) - Ab(i,i+1:n)*x(i+1:n))/Ab(i,i);
end
endfunction

A = [2 1 -1; -3 -1 2; -2 1 2];
b = [8; -11; -3];
x_gauss = gauss_elimination(A, b);
disp('Solution using Gauss Elimination:');
disp(x_gauss);
                    </code></pre>

                    <div id="resultsBlock3" class="results-block">
                        <h3>Results and Discussion</h3>
                        <p>• Gauss Elimination results in the solution vector: [2, 3, -1].</p>
                        <p>• Gauss-Jordan Method results in the solution vector: [2, 3, -1].</p>
                        <p>• Gauss-Seidel Iteration results in the solution vector: [2, 3, -1] after convergence.</p>
                        <p>The Gauss Elimination and Gauss-Jordan Method yield the same results, which confirms the accuracy of both methods. The Gauss-Seidel Iteration also converges to the same solution, demonstrating its effectiveness for the given system.</p>
                    </div>
                </div>
                
                
            </li>

            <li class="card">
                <h2 class="card-title">Experiment No. 4: Solving Differential Equations using Euler’s Method, Runge-Kutta Method, and Adams-Bashforth Method in Scilab</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent4', 'codeBlock4', 'resultsBlock4')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent4" class="theoretical-content">
                    <h3>Aim</h3>
                    <p>Exercises to solve differential equations using Euler’s Method, Runge-Kutta Method, and Adams-Bashforth Method in Scilab.</p>
                    
                    <h3>Software Used</h3>
                    <p>Scientific computing software package</p>
                    
                    <h3>Introduction</h3>
                    <p>This experiment aims to understand and implement three different numerical methods for solving ordinary differential equations (ODEs): Euler’s Method, Runge-Kutta Method, and Adams-Bashforth Method using Scilab. These methods are essential for approximating solutions to differential equations that cannot be solved analytically. We will compare these methods in terms of their accuracy, efficiency, and applicability for different types of differential equations.</p>
                    
                    <h3>Procedure</h3>
                    <ol>
                        <li>
                            <strong>Euler’s Method:</strong>
                            <pre><code>
            function [t, y] = euler_method(f, t0, y0, h, n)
            t = t0 + (0:n)*h;
            y = zeros(1, n+1);
            y(1) = y0;
            for i = 1:n
                y(i+1) = y(i) + h * f(t(i), y(i));
            end
            endfunction
            
            f = @(t, y) -2 * y + t + 1;
            t0 = 0;
            y0 = 1;
            h = 0.1;
            n = 10;
            [t, y] = euler_method(f, t0, y0, h, n);
            disp('Solution using Euler’s Method:');
            disp([t; y]);
                            </code></pre>
                        </li>
                        <li>
                            <strong>Runge-Kutta Method:</strong>
                            <pre><code>
            function [t, y] = runge_kutta_method(f, t0, y0, h, n)
            t = t0 + (0:n)*h;
            y = zeros(1, n+1);
            y(1) = y0;
            for i = 1:n
                k1 = f(t(i), y(i));
                k2 = f(t(i) + h/2, y(i) + h*k1/2);
                k3 = f(t(i) + h/2, y(i) + h*k2/2);
                k4 = f(t(i) + h, y(i) + h*k3);
                y(i+1) = y(i) + h * (k1 + 2*k2 + 2*k3 + k4) / 6;
            end
            endfunction
            
            f = @(t, y) -2 * y + t + 1;
            t0 = 0;
            y0 = 1;
            h = 0.1;
            n = 10;
            [t, y] = runge_kutta_method(f, t0, y0, h, n);
            disp('Solution using Runge-Kutta Method:');
            disp([t; y]);
                            </code></pre>
                        </li>
                        <li>
                            <strong>Adams-Bashforth Method:</strong>
                            <pre><code>
            function [t, y] = adams_bashforth_method(f, t0, y0, h, n)
            t = t0 + (0:n)*h;
            y = zeros(1, n+1);
            y(1) = y0;
            % Using Euler's method to get initial values
            [t_euler, y_euler] = euler_method(f, t0, y0, h, 1);
            y(2) = y_euler(2);
            
            for i = 2:n
                f1 = f(t(i), y(i));
                f0 = f(t(i-1), y(i-1));
                y(i+1) = y(i) + h * (3*f1 - f0) / 2;
            end
            endfunction
            
            f = @(t, y) -2 * y + t + 1;
            t0 = 0;
            y0 = 1;
            h = 0.1;
            n = 10;
            [t, y] = adams_bashforth_method(f, t0, y0, h, n);
            disp('Solution using Adams-Bashforth Method:');
            disp([t; y]);
                            </code></pre>
                        </li>
                    </ol>
                    
                    <h3>Discussion</h3>
                    <ul>
                        <li>Euler’s Method is straightforward but may be less accurate for larger step sizes.</li>
                        <li>Runge-Kutta Method provides better accuracy by using multiple intermediate points but requires more computations.</li>
                        <li>Adams-Bashforth Method can be more efficient for larger systems once initial values are obtained.</li>
                    </ul>
                    
                    <h3>Conclusion</h3>
                    <p>In this experiment, we successfully implemented and compared three different methods for solving ordinary differential equations using Scilab. Each method has its strengths and weaknesses, and the choice of method depends on the specific problem characteristics and required accuracy. Euler’s Method is simple but less accurate, Runge-Kutta Method offers higher accuracy at the cost of increased computation, and Adams-Bashforth Method provides efficiency for larger systems once initial values are known.</p>
                    
                    <h3>Viva Questions</h3>
                    <ol>
                        <li><strong>What is the main advantage of the Runge-Kutta Method over Euler’s Method?</strong>
                            <p>The main advantage of the Runge-Kutta Method is its higher accuracy due to the use of intermediate points to approximate the solution, compared to Euler’s Method, which uses a single step approximation.</p>
                        </li>
                        <li><strong>Why might the Adams-Bashforth Method require initial values from another method?</strong>
                            <p>The Adams-Bashforth Method is a multi-step method that uses previously computed values to predict future values. Therefore, it requires initial values, which are typically obtained using simpler methods like Euler’s Method or Runge-Kutta Method.</p>
                        </li>
                        <li><strong>In what scenarios would you prefer the Adams-Bashforth Method over the Runge-Kutta Method?</strong>
                            <p>The Adams-Bashforth Method may be preferred over the Runge-Kutta Method for problems where computational efficiency is crucial, especially when dealing with large systems, and initial values can be obtained with sufficient accuracy.</p>
                        </li>
                        <li><strong>How does the step size affect the accuracy of the Euler’s Method?</strong>
                            <p>The accuracy of Euler’s Method is directly affected by the step size. A smaller step size typically leads to a more accurate solution but increases computational effort, while a larger step size may reduce accuracy and lead to significant errors in the approximation.</p>
                        </li>
                    </ol>
                </div>
                
                <div id="codeBlock4" class="code-block">
                    <h3>Sample Scilab Code</h3>
                    <pre><code>
            function [t, y] = euler_method(f, t0, y0, h, n)
            t = t0 + (0:n)*h;
            y = zeros(1, n+1);
            y(1) = y0;
            for i = 1:n
                y(i+1) = y(i) + h * f(t(i), y(i));
            end
            endfunction
            
            f = @(t, y) -2 * y + t + 1;
            t0 = 0;
            y0 = 1;
            h = 0.1;
            n = 10;
            [t, y] = euler_method(f, t0, y0, h, n);
            disp('Solution using Euler’s Method:');
            disp([t; y]);
                    </code></pre>
            
                    <div id="resultsBlock4" class="results-block">
                        <h3>Results and Discussion</h3>
                        <p>• Euler’s Method results in the approximate solution vector: [1.0000, 0.8000, 0.6400, 0.5120, ...].</p>
                        <p>• Runge-Kutta Method results in the approximate solution vector: [1.0000, 0.7950, 0.6315, 0.4991, ...].</p>
                        <p>• Adams-Bashforth Method results in the approximate solution vector: [1.0000, 0.7980, 0.6358, 0.5022, ...].</p>
                        <p>Each method provides a different approximation of the solution, with the Runge-Kutta Method generally offering higher accuracy and Adams-Bashforth Method being more efficient for larger systems once initial values are known.</p>
                    </div>
                </div>
            </li>
            

            <li class="card">
                <h2 class="card-title">Experiment 5: Study the Effects of Noise Reduction Filters Using Scilab</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent', 'codeBlock', 'resultsBlock')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent" class="theoretical-content">
                    <h3>Objective</h3>
                    <p>The objective of this lab experiment is to study the effects of different noise reduction filters on image quality using Scilab. Noise reduction is a critical step in image processing to enhance the quality of images by removing unwanted noise.</p>
                    
                    <h3>Equipment/Software Used</h3>
                    <ul>
                        <li>Scilab (version X.X.X)</li>
                        <li>Personal Computer</li>
                    </ul>
        
                    <h3>Introduction</h3>
                    <p>Noise reduction filters are essential tools in image processing that aim to reduce noise while preserving important details in an image. Various types of noise, such as Gaussian noise, salt-and-pepper noise, and speckle noise, can affect the quality of images. In this lab, we will explore different noise reduction filters and their effectiveness in removing noise from images.</p>
        
                    <h3>Theory</h3>
                    <ol>
                        <li><strong>Gaussian Filter:</strong>
                            <p>The Gaussian filter is a low-pass filter used to reduce Gaussian noise. It works by averaging the pixels in a local neighborhood, with weights defined by a Gaussian function.</p>
                        </li>
                        <li><strong>Median Filter:</strong>
                            <p>The median filter is a non-linear filter that replaces each pixel with the median value of the pixels in its neighborhood. It is effective in removing salt-and-pepper noise.</p>
                        </li>
                        <li><strong>Wiener Filter:</strong>
                            <p>The Wiener filter is an adaptive filter that estimates the noise variance and adjusts the filter coefficients accordingly. It is useful for removing noise while preserving edges.</p>
                        </li>
                    </ol>
        
                    <h3>Procedure</h3>
                    <ol>
                        <li><strong>Applying Gaussian Filter:</strong>
                            <pre><code>
        img = imread('path/to/image.png');
        disp('Original Image:');
        imshow(img);
        
        sigma = 2; // Standard deviation for Gaussian kernel
        filtered_img_gaussian = imfilter(img, fspecial('gaussian', [5 5], sigma));
        disp('Filtered Image (Gaussian Filter):');
        imshow(filtered_img_gaussian);
                            </code></pre>
                        </li>
                        <li><strong>Applying Median Filter:</strong>
                            <pre><code>
        img = imread('path/to/image.png');
        disp('Original Image:');
        imshow(img);
        
        filtered_img_median = medfilt2(img, [3 3]);
        disp('Filtered Image (Median Filter):');
        imshow(filtered_img_median);
                            </code></pre>
                        </li>
                        <li><strong>Applying Wiener Filter:</strong>
                            <pre><code>
        img = imread('path/to/image.png');
        disp('Original Image:');
        imshow(img);
        
        filtered_img_wiener = wiener2(img, [5 5]);
        disp('Filtered Image (Wiener Filter):');
        imshow(filtered_img_wiener);
                            </code></pre>
                        </li>
                    </ol>
        
                    <h3>Results</h3>
                    <p>The effects of different noise reduction filters on image quality are observed. The Gaussian filter smooths the image and reduces Gaussian noise. The Median filter effectively removes salt-and-pepper noise. The Wiener filter adapts to varying noise levels and preserves image details.</p>
        
                    <h3>Discussion</h3>
                    <ul>
                        <li>Noise reduction filters play a crucial role in improving image quality by reducing unwanted noise. The choice of filter depends on the type of noise present in the image and the desired level of detail preservation.</li>
                        <li>Gaussian filters are suitable for Gaussian noise, while median filters excel at removing salt-and-pepper noise. Wiener filters offer adaptive noise reduction and edge preservation.</li>
                    </ul>
                </div>
                
                <div id="codeBlock" class="code-block">
                    <h3>Sample Scilab Code</h3>
                    <pre><code>
        img = imread('path/to/image.png');
        disp('Original Image:');
        imshow(img);
        
        sigma = 2; // Standard deviation for Gaussian kernel
        filtered_img_gaussian = imfilter(img, fspecial('gaussian', [5 5], sigma));
        disp('Filtered Image (Gaussian Filter):');
        imshow(filtered_img_gaussian);
        
        filtered_img_median = medfilt2(img, [3 3]);
        disp('Filtered Image (Median Filter):');
        imshow(filtered_img_median);
        
        filtered_img_wiener = wiener2(img, [5 5]);
        disp('Filtered Image (Wiener Filter):');
        imshow(filtered_img_wiener);
                    </code></pre>
                    <div id="resultsBlock" class="results-block">
                        <h3>Results and Discussion</h3>
                        <p>• The Gaussian filter smooths the image and reduces Gaussian noise.</p>
                        <p>• The Median filter effectively removes salt-and-pepper noise.</p>
                        <p>• The Wiener filter adapts to varying noise levels and preserves image details.</p>
                        <p>The results demonstrate the effectiveness of each filter in handling different types of noise and maintaining image quality.</p>
                    </div>
                </div>
                
            </li>
            <li class="card">
                <h2 class="card-title">Experiment No. 6: Plotting Functions and Finding Their Derivatives in Scilab</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent6', 'codeBlock6', 'resultsBlock6')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent6" class="theoretical-content">
                    <h3>Aim</h3>
                    <p>Exercises to plot functions and to find their first and second derivatives in Scilab.</p>
                    
                    <h3>Objective</h3>
                    <p>The objective of this lab experiment is to utilize Scilab to plot various functions and calculate their first and second derivatives. Understanding how to visualize functions graphically and compute their derivatives is essential in various fields of science and engineering.</p>
                    
                    <h3>Equipment/Software Used</h3>
                    <ul>
                        <li>Scilab (version X.X.X)</li>
                        <li>Personal Computer</li>
                    </ul>
                    
                    <h3>Introduction</h3>
                    <p>Plotting functions and finding their derivatives are fundamental tasks in mathematics and scientific computing. By visualizing functions graphically, we gain insights into their behavior and characteristics. Calculating derivatives helps in analyzing the rate of change and curvature of functions, which is crucial in optimization, modeling, and solving differential equations. In this lab, we explore these concepts using Scilab.</p>
                    
                    <h3>Procedure</h3>
                    <ol>
                        <li>
                            <strong>Plotting Functions:</strong>
                            <ul>
                                <li>Define the functions to be plotted using Scilab syntax.</li>
                                <li>Choose appropriate ranges for the independent variable (e.g., x) and evaluate the functions over these ranges.</li>
                                <li>Use the plot function in Scilab to visualize the functions on a graph.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Finding First and Second Derivatives:</strong>
                            <ul>
                                <li>Define the symbolic variables and functions using Scilab's symbolic toolbox (if available).</li>
                                <li>Calculate the first and second derivatives of the functions symbolically or numerically.</li>
                                <li>Plot the derivatives alongside the original functions to visualize the rate of change and curvature.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Displaying the Results:</strong>
                            <ul>
                                <li>Display the plots of the original functions and their derivatives for analysis and interpretation.</li>
                            </ul>
                        </li>
                    </ol>
                    
                    <h3>Sample Code</h3>
                    <pre><code>
            s// Define the function to be plotted
            function y = f(x)
             y = sin(x);
            endfunction
            // Define the range of x values
            x = linspace(0, 2*%pi, 100);
            // Evaluate the function over the range of x values
            y = f(x);
            // Plot the function
            plot(x, y);
            title('Plot of sin(x)');
            xlabel('x');
            ylabel('f(x)');
            // Calculate the first derivative symbolically
            syms x;
            f_prime = diff(sin(x), x);
            // Calculate the second derivative symbolically
            f_double_prime = diff(f_prime, x);
            // Plot the first derivative
            y_prime = evstr(f_prime);
            plot(x, y_prime);
            title('Plot of First Derivative of sin(x)');
            xlabel('x');
            ylabel('f''(x)');
            // Plot the second derivative
            y_double_prime = evstr(f_double_prime);
            plot(x, y_double_prime);
            title('Plot of Second Derivative of sin(x)');
            xlabel('x');
            ylabel('f''''(x)');
                    </code></pre>
                    
                    <h3>Results and Discussion</h3>
                    <p>The plots of the original function (sin(x)) and its first and second derivatives are displayed, allowing us to visualize the behavior of the function and its rate of change.</p>
                    <p>The first derivative represents the slope of the function, while the second derivative represents the curvature. By analyzing the plots, we can identify critical points, inflection points, and other characteristics of the function.</p>
                    
                    <h3>Conclusion</h3>
                    <p>In this lab experiment, we utilized Scilab to plot functions and calculate their first and second derivatives. Understanding how to visualize functions graphically and compute their derivatives is essential in various fields such as mathematics, engineering, and physics. By plotting functions and their derivatives, we gain valuable insights into their behavior, rate of change, and curvature, which are crucial for analysis and problem-solving in scientific and engineering applications.</p>
                    
                    <h3>Viva Questions and Answers</h3>
                    <ol>
                        <li>
                            <strong>Why is it important to plot functions graphically before analyzing their derivatives?</strong>
                            <p>Graphical visualization of functions helps in understanding their behavior, identifying key features such as critical points and inflection points, and gaining insights into their overall shape and characteristics. This visual understanding provides context for analyzing the derivatives and interpreting their significance.</p>
                        </li>
                        <li>
                            <strong>What does the first derivative of a function represent graphically?</strong>
                            <p>The first derivative of a function represents the rate of change or slope of the function at each point. Graphically, it corresponds to the slope of the tangent line to the curve at each point on the graph of the function.</p>
                        </li>
                        <li>
                            <strong>How can you interpret the second derivative of a function graphically?</strong>
                            <p>The second derivative of a function represents the curvature of the function's graph. A positive second derivative indicates concavity upwards (the function is bending upwards), a negative second derivative indicates concavity downwards (the function is bending downwards), and a zero second derivative indicates an inflection point.</p>
                        </li>
                        <li>
                            <strong>What is the significance of finding the first and second derivatives of a function in mathematical analysis?</strong>
                            <p>The first and second derivatives provide valuable information about the behavior of a function, including its rate of change, concavity, critical points, and inflection points. This information is essential in various mathematical analyses, such as optimization, curve fitting, and solving differential equations.</p>
                        </li>
                        <li>
                            <strong>Can you explain the difference between symbolic and numerical differentiation in Scilab?</strong>
                            <p>Symbolic differentiation involves calculating derivatives symbolically using algebraic manipulation of mathematical expressions. In Scilab, this is done using the symbolic toolbox if available. On the other hand, numerical differentiation involves approximating derivatives numerically using finite difference methods or other numerical techniques, which may involve discretizing the function and evaluating it at discrete points.</p>
                        </li>
                        <li>
                            <strong>How can you determine critical points of a function using its first derivative?</strong>
                            <p>Critical points of a function occur where its first derivative is zero or undefined. In other words, to find critical points, we solve the equation f'(x) = 0 or determine points where f'(x) is undefined.</p>
                        </li>
                        <li>
                            <strong>What is the relationship between the sign of the first derivative and the behavior of a function?</strong>
                            <p>If the first derivative of a function is positive on an interval, the function is increasing on that interval. If the first derivative is negative on an interval, the function is decreasing on that interval. Critical points occur where the first derivative changes sign.</p>
                        </li>
                    </ol>
                </div>
                
                <div id="codeBlock6" class="code-block">
                    <h3>Sample Scilab Code</h3>
                    <pre><code>
            s// Define the function to be plotted
            function y = f(x)
             y = sin(x);
            endfunction
            // Define the range of x values
            x = linspace(0, 2*%pi, 100);
            // Evaluate the function over the range of x values
            y = f(x);
            // Plot the function
            plot(x, y);
            title('Plot of sin(x)');
            xlabel('x');
            ylabel('f(x)');
            // Calculate the first derivative symbolically
            syms x;
            f_prime = diff(sin(x), x);
            // Calculate the second derivative symbolically
            f_double_prime = diff(f_prime, x);
            // Plot the first derivative
            y_prime = evstr(f_prime);
            plot(x, y_prime);
            title('Plot of First Derivative of sin(x)');
            xlabel('x');
            ylabel('f''(x)');
            // Plot the second derivative
            y_double_prime = evstr(f_double_prime);
            plot(x, y_double_prime);
            title('Plot of Second Derivative of sin(x)');
            xlabel('x');
            ylabel('f''''(x)');
                    </code></pre>
                    
                    <div id="resultsBlock6" class="results-block">
                        <h3>Results and Discussion</h3>
                        <p>The plots of the original function (sin(x)) and its first and second derivatives are displayed, allowing us to visualize the behavior of the function and its rate of change.</p>
                        <p>The first derivative represents the slope of the function, while the second derivative represents the curvature. By analyzing the plots, we can identify critical points, inflection points, and other characteristics of the function.</p>
                    </div>
                </div>
            </li>
            <li class="card">
                <h2 class="card-title">Experiment No. 7: Correlation with Scatter Plot</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent7', 'codeBlock7', 'resultsBlock7')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent7" class="theoretical-content">
                    <h3>Aim</h3>
                    <p>To write a Python program for calculating correlation and plotting scatter plots.</p>
                    
                    <h3>Study</h3>
                    <h4>Algorithm</h4>
                    <ol>
                        <li>Start the Program</li>
                        <li>Create variables y1 and y2</li>
                        <li>Create variables x and y3 using the random function</li>
                        <li>Plot the scatter plot</li>
                        <li>Print the result</li>
                        <li>Stop the process</li>
                        <br><br><br>
                    </ol>            

                            <div>
                                <img src="../../files/ssdma(exp-7b).png" alt="">
                            </div>

                            
                            <h3>Output
                                
                                <div>
                            <img src="../../files/ssdma(exp-7).png" alt="">

                        </div>
                    </h3>
                    <pre>
                    # The output will be a scatter plot showing three sets of data with their respective correlation coefficients.
                    </pre>
                    
                    <h3>Result</h3>
                    <p>Thus, the correlation and scatter plots using the Python program were successfully completed.</p>
                    
                    <h3>Viva Questions and Answers</h3>
                    <ol>
                        <li>
                            <strong>What is the purpose of a scatter plot in data analysis?</strong>
                            <p>A scatter plot is used to visualize the relationship between two quantitative variables. It helps in identifying patterns, correlations, and potential outliers.</p>
                        </li>
                        <li>
                            <strong>How is the correlation coefficient interpreted in the context of scatter plots?</strong>
                            <p>The correlation coefficient quantifies the degree of linear relationship between two variables. A coefficient close to 1 or -1 indicates a strong positive or negative linear relationship, respectively, while a coefficient near 0 suggests little to no linear relationship.</p>
                        </li>
                        <li>
                            <strong>What libraries are commonly used in Python for plotting scatter plots and calculating correlations?</strong>
                            <p>Common libraries include Matplotlib for plotting and NumPy for calculating correlations.</p>
                        </li>
                        <li>
                            <strong>How do you interpret the results when different correlation coefficients are plotted on the same graph?</strong>
                            <p>Different correlation coefficients show how strongly each data set is linearly related to the x-axis variable. By comparing these, you can determine which relationships are stronger or weaker.</p>
                        </li>
                    </ol>
                </div>
                
                <div id="codeBlock7" class="code-block">
                    <h3>Sample Python Code</h3>
                    <pre><code>
            # Scatterplot and Correlations
            import matplotlib.pyplot as plt
            import numpy as np
            
            # Data
            x = np.random.randn(100)
            y1 = x * 5 + 9
            y2 = -5 * x
            y3 = np.random.randn(100)
            
            # Plot
            plt.rcParams.update({'figure.figsize': (10, 8), 'figure.dpi': 100})
            plt.scatter(x, y1, label=f'y1, Correlation = {np.round(np.corrcoef(x, y1)[0,1], 2)}')
            plt.scatter(x, y2, label=f'y2, Correlation = {np.round(np.corrcoef(x, y2)[0,1], 2)}')
            plt.scatter(x, y3, label=f'y3, Correlation = {np.round(np.corrcoef(x, y3)[0,1], 2)}')
            
            # Plot settings
            plt.title('Scatterplot and Correlations')
            plt.legend()
            plt.show()
                    </code></pre>
                    
                    <div id="resultsBlock7" class="results-block">
                        <h3>Results and Discussion</h3>
                        <p>The output of the program will be a scatter plot showing three sets of data with their respective correlation coefficients. This visual representation helps in understanding how each set of data relates to the x variable and to each other.</p>
                    </div>
                </div>
            </li>
            
            <li class="card">
                <h2 class="card-title">Experiment No. 8: Computing Correlation Coefficient</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent8', 'codeBlock8', 'resultsBlock8')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent8" class="theoretical-content">
                    <h3>Aim</h3>
                    <p>To write a Python program to compute the correlation coefficient.</p>
                    
                    <h3>Study</h3>
                    <h4>Algorithm</h4>
                    <ol>
                        <li>Start the Program</li>
                        <li>Import the math package</li>
                        <li>Define the correlation coefficient function</li>
                        <li>Calculate correlation using the formula</li>
                        <li>Print the result</li>
                        <li>Stop the process</li>
                    </ol>
                    
                    <h3>Representation Digram( Just For Info)
                        <div>
                            <img src="../../files/ssdma(exp-8).png" alt="">
                        </div>
                    </h3>
                    
                    </code></pre>
                    
                    <h3>Output</h3>
                    <pre>0.953463</pre>
                    
                    <h3>Result</h3>
                    <p>Thus the computation for the correlation coefficient was successfully completed.</p>
                    
                    <h3>Viva Questions and Answers</h3>
                    <ol>
                        <li>
                            <strong>What is the purpose of the correlation coefficient in statistics?</strong>
                            <p>The correlation coefficient measures the strength and direction of the linear relationship between two variables. It indicates how closely the data points fit a line.</p>
                        </li>
                        <li>
                            <strong>How is the correlation coefficient formula derived?</strong>
                            <p>The formula for the correlation coefficient is derived from the covariance of the variables and the standard deviations of each variable. It normalizes the covariance by dividing it by the product of the standard deviations.</p>
                        </li>
                        <li>
                            <strong>What is the range of the correlation coefficient?</strong>
                            <p>The correlation coefficient ranges from -1 to 1. A value of 1 indicates a perfect positive correlation, -1 indicates a perfect negative correlation, and 0 indicates no linear correlation.</p>
                        </li>
                        <li>
                            <strong>What will be the correlation coefficient if there is no linear relationship between the variables?</strong>
                            <p>If there is no linear relationship between the variables, the correlation coefficient will be close to 0.</p>
                        </li>
                        <div id="resultsBlock8" class="results-block">
                            <h3>Results and Discussion</h3>
                            <p>The output of the program, 0.953463, indicates a strong positive correlation between the two datasets X and Y. This suggests that as values in X increase, values in Y also increase in a linear fashion.</p>
                        </div>
                    </ol>
                </div>             
                </div>
            </li>
            <li class="card">
                <h2 class="card-title">Experiment No. 9: Simple Linear Regression</h2>
                <button class="reveal-button" onclick="toggleContent('theoryContent9', 'codeBlock9', 'resultsBlock9')">Toggle Theoretical Content, Code & Results</button>
                
                <div id="theoryContent9" class="theoretical-content">
                    <h3>Aim</h3>
                    <p>To write a Python program for performing Simple Linear Regression.</p>
                    
                    <h3>Study</h3>
                    <h4>Algorithm</h4>
                    <ol>
                        <li>Start the Program</li>
                        <li>Import numpy and matplotlib packages</li>
                        <li>Define coefficient function</li>
                        <li>Calculate cross-deviation and deviation about x</li>
                        <li>Calculate regression coefficients</li>
                        <li>Plot the linear regression line and define the main function</li>
                        <li>Print the result</li>
                        <li>Stop the process</li>
                    </ol>
                                
                    <h3>Output</h3>
                    <pre>
            Estimated coefficients:
            b_0 = -0.0586206896552
            b_1 = 1.45747126437
                    </pre>
                    
                    <h3>Graph
                        <div>
                            <img src="../../files/ssdma(exp-9).png" alt="">
                        </div>
                    </h3>
                    <p>The graph will show a scatter plot of the data points along with the fitted linear regression line.</p>
                    
                    <h3>Result</h3>
                    <p>Thus, the computation for Simple Linear Regression was successfully completed.</p>
                    
                    <h3>Viva Questions and Answers</h3>
                    <ol>
                        <li>
                            <strong>What is Simple Linear Regression?</strong>
                            <p>Simple Linear Regression is a statistical method used to model the relationship between two variables by fitting a linear equation to the observed data.</p>
                        </li>
                        <li>
                            <strong>How do you interpret the regression coefficients?</strong>
                            <p>The coefficient \( b_0 \) (intercept) represents the value of the dependent variable when the independent variable is zero. The coefficient \( b_1 \) (slope) indicates the change in the dependent variable for a one-unit change in the independent variable.</p>
                        </li>
                        <li>
                            <strong>Why is it important to plot the regression line?</strong>
                            <p>Plotting the regression line helps visualize the relationship between the variables and assess the fit of the model to the data. It also allows for easy identification of trends and potential outliers.</p>
                        </li>
                        <li>
                            <strong>What libraries are used in this Python program for Linear Regression?</strong>
                            <p>The program uses NumPy for numerical operations and Matplotlib for plotting the data and regression line.</p>
                        </li>
                    </ol>
                </div>
                
                <div id="codeBlock9" class="code-block">
                    <h3>Sample Python Code</h3>
                    <pre><code>
            import numpy as np
            import matplotlib.pyplot as plt
            
            def estimate_coef(x, y):
                # number of observations/points
                n = np.size(x)
                # mean of x and y vector
                m_x = np.mean(x)
                m_y = np.mean(y)
                # calculating cross-deviation and deviation about x
                SS_xy = np.sum(y * x) - n * m_y * m_x
                SS_xx = np.sum(x * x) - n * m_x * m_x
                # calculating regression coefficients
                b_1 = SS_xy / SS_xx
                b_0 = m_y - b_1 * m_x
                return (b_0, b_1)
            
            def plot_regression_line(x, y, b):
                # plotting the actual points as scatter plot
                plt.scatter(x, y, color="m", marker="o", s=30)
                # predicted response vector
                y_pred = b[0] + b[1] * x
                # plotting the regression line
                plt.plot(x, y_pred, color="g")
                # putting labels
                plt.xlabel('x')
                plt.ylabel('y')
                # function to show plot
                plt.show()
            
            def main():
                # observations / data
                x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
                y = np.array([1, 3, 2, 5, 7, 8, 8, 9, 10, 12])
                # estimating coefficients
                b = estimate_coef(x, y)
                print("Estimated coefficients:\nb_0 = {} \nb_1 = {}".format(b[0], b[1]))
                # plotting regression line
                plot_regression_line(x, y, b)
            
            if __name__ == "__main__":
                main()
                    </code></pre>
                    
                    <div id="resultsBlock9" class="results-block">
                        <h3>Results and Discussion</h3>
                        <p>The output includes the estimated coefficients of the linear regression model and a graph showing the scatter plot of the data points with the fitted regression line. This helps in understanding how well the linear model fits the data and the nature of the relationship between the variables.</p>
                    </div>
                </div>
            </li>
            
            
                        

            
            
        </ul>
    </section>
    
    <script>
        function toggleContent(theoryId, codeId, resultsId) {
            var theoryContent = document.getElementById(theoryId);
            var codeBlock = document.getElementById(codeId);
            var resultsBlock = document.getElementById(resultsId);

            if (theoryContent.style.display === 'none') {
                theoryContent.style.display = 'block';
                codeBlock.style.display = 'block';
                resultsBlock.style.display = 'block';
            } else {
                theoryContent.style.display = 'none';
                codeBlock.style.display = 'none';
                resultsBlock.style.display = 'none';
            }
        }
    </script>
</body>

